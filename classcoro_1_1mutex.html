<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcoro: coro::mutex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcoro
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Coroutine support library for C++20</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecoro.html">coro</a></li><li class="navelem"><a class="el" href="classcoro_1_1mutex.html">mutex</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcoro_1_1mutex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">coro::mutex Class Reference<div class="ingroups"><a class="el" href="group__awaitable.html">Awaitables</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Mutex which allows locking across co_await and co_yield suspend points.  
 <a href="classcoro_1_1mutex.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mutex_8h_source.html">mutex.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for coro::mutex:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classcoro_1_1mutex__coll__graph.png" border="0" usemap="#acoro_1_1mutex_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro_1_1mutex_1_1awaiter.html">awaiter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">awaiter is object used in most of cases by coroutines, however it is building block of this class  <a href="classcoro_1_1mutex_1_1awaiter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro_1_1mutex_1_1awaiter__cb.html">awaiter_cb</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">awaiter with a callback function  <a href="classcoro_1_1mutex_1_1awaiter__cb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro_1_1mutex_1_1ownership.html">ownership</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tracks ownership  <a href="classcoro_1_1mutex_1_1ownership.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b5fb2fd2995e2210181de3c4211ca6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoro_1_1mutex_1_1ownership.html">ownership</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro_1_1mutex.html#a1b5fb2fd2995e2210181de3c4211ca6f">try_lock</a> ()</td></tr>
<tr class="memdesc:a1b5fb2fd2995e2210181de3c4211ca6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">try to lock  <a href="classcoro_1_1mutex.html#a1b5fb2fd2995e2210181de3c4211ca6f">More...</a><br /></td></tr>
<tr class="separator:a1b5fb2fd2995e2210181de3c4211ca6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd530af9e366966cc459b81cd4850705"><td class="memItemLeft" align="right" valign="top"><a id="acd530af9e366966cc459b81cd4850705"></a>
<a class="el" href="classcoro_1_1mutex_1_1awaiter.html">awaiter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro_1_1mutex.html#acd530af9e366966cc459b81cd4850705">operator co_await</a> ()</td></tr>
<tr class="memdesc:acd530af9e366966cc459b81cd4850705"><td class="mdescLeft">&#160;</td><td class="mdescRight">co_await support <br /></td></tr>
<tr class="separator:acd530af9e366966cc459b81cd4850705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0067038a6413cc3c34bfca3a8ef63314"><td class="memItemLeft" align="right" valign="top"><a id="a0067038a6413cc3c34bfca3a8ef63314"></a>
<a class="el" href="classcoro_1_1mutex_1_1ownership.html">ownership</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro_1_1mutex.html#a0067038a6413cc3c34bfca3a8ef63314">lock_sync</a> ()</td></tr>
<tr class="memdesc:a0067038a6413cc3c34bfca3a8ef63314"><td class="mdescLeft">&#160;</td><td class="mdescRight">lock synchronously <br /></td></tr>
<tr class="separator:a0067038a6413cc3c34bfca3a8ef63314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fc3958880800e8420a2b2ef34932c1"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; ownership &gt; Fn&gt; </td></tr>
<tr class="memitem:a66fc3958880800e8420a2b2ef34932c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro_1_1mutex.html#a66fc3958880800e8420a2b2ef34932c1">lock_callback</a> (Fn &amp;&amp;fn) noexcept</td></tr>
<tr class="memdesc:a66fc3958880800e8420a2b2ef34932c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">lock and call a function when access is granted  <a href="classcoro_1_1mutex.html#a66fc3958880800e8420a2b2ef34932c1">More...</a><br /></td></tr>
<tr class="separator:a66fc3958880800e8420a2b2ef34932c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0ff76f662e2b2dfddf1501f8d54e67"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; ownership &gt; Fn, std::size_t sz&gt; </td></tr>
<tr class="memitem:adc0ff76f662e2b2dfddf1501f8d54e67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro_1_1mutex.html#adc0ff76f662e2b2dfddf1501f8d54e67">lock_callback</a> (Fn &amp;&amp;fn, char(&amp;buffer)[sz])</td></tr>
<tr class="memdesc:adc0ff76f662e2b2dfddf1501f8d54e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">lock and call a function when access is granted  <a href="classcoro_1_1mutex.html#adc0ff76f662e2b2dfddf1501f8d54e67">More...</a><br /></td></tr>
<tr class="separator:adc0ff76f662e2b2dfddf1501f8d54e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae4442e1f6d17f0cf3cfa45a16256b83a"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:ae4442e1f6d17f0cf3cfa45a16256b83a"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro_1_1mutex.html#ae4442e1f6d17f0cf3cfa45a16256b83a">lock_callback_buffer_size</a> = sizeof(<a class="el" href="classcoro_1_1mutex_1_1awaiter__cb.html">awaiter_cb</a>&lt;Fn, true&gt;)</td></tr>
<tr class="memdesc:ae4442e1f6d17f0cf3cfa45a16256b83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">contains required size of static buffer to hold awaiter for given function  <a href="classcoro_1_1mutex.html#ae4442e1f6d17f0cf3cfa45a16256b83a">More...</a><br /></td></tr>
<tr class="separator:ae4442e1f6d17f0cf3cfa45a16256b83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae9c73d87232d3dd22e4dd45c0719206e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro_1_1mutex.html#ae9c73d87232d3dd22e4dd45c0719206e">try_acquire</a> ()</td></tr>
<tr class="memdesc:ae9c73d87232d3dd22e4dd45c0719206e"><td class="mdescLeft">&#160;</td><td class="mdescRight">tries to acquire  <a href="classcoro_1_1mutex.html#ae9c73d87232d3dd22e4dd45c0719206e">More...</a><br /></td></tr>
<tr class="separator:ae9c73d87232d3dd22e4dd45c0719206e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e661447e136717a63e38cf9047f20b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro_1_1mutex.html#ad0e661447e136717a63e38cf9047f20b">do_lock</a> (<a class="el" href="classcoro_1_1mutex_1_1awaiter.html">awaiter</a> *awt)</td></tr>
<tr class="memdesc:ad0e661447e136717a63e38cf9047f20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">initiate lock operation  <a href="classcoro_1_1mutex.html#ad0e661447e136717a63e38cf9047f20b">More...</a><br /></td></tr>
<tr class="separator:ad0e661447e136717a63e38cf9047f20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a4ba298325045f272db9ea9c2e5098"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro_1_1mutex.html#a62a4ba298325045f272db9ea9c2e5098">build_queue</a> (<a class="el" href="classcoro_1_1mutex_1_1awaiter.html">awaiter</a> *r, <a class="el" href="classcoro_1_1mutex_1_1awaiter.html">awaiter</a> *stop)</td></tr>
<tr class="memdesc:a62a4ba298325045f272db9ea9c2e5098"><td class="mdescLeft">&#160;</td><td class="mdescRight">builds internal queue  <a href="classcoro_1_1mutex.html#a62a4ba298325045f272db9ea9c2e5098">More...</a><br /></td></tr>
<tr class="separator:a62a4ba298325045f272db9ea9c2e5098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda886fc0b4171935329781e05d92d24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoro_1_1prepared__coro.html">prepared_coro</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro_1_1mutex.html#adda886fc0b4171935329781e05d92d24">unlock</a> ()</td></tr>
<tr class="memdesc:adda886fc0b4171935329781e05d92d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">unlock the lock  <a href="classcoro_1_1mutex.html#adda886fc0b4171935329781e05d92d24">More...</a><br /></td></tr>
<tr class="separator:adda886fc0b4171935329781e05d92d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59c072bf2835eff157b8c59adf1c0ad"><td class="memItemLeft" align="right" valign="top"><a id="ab59c072bf2835eff157b8c59adf1c0ad"></a>
<a class="el" href="classcoro_1_1mutex_1_1ownership.html">ownership</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro_1_1mutex.html#ab59c072bf2835eff157b8c59adf1c0ad">make_ownership</a> ()</td></tr>
<tr class="memdesc:ab59c072bf2835eff157b8c59adf1c0ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates ownership object <br /></td></tr>
<tr class="separator:ab59c072bf2835eff157b8c59adf1c0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a6d73b5920fdf3bd9e2959a26ffb20402"><td class="memItemLeft" align="right" valign="top"><a id="a6d73b5920fdf3bd9e2959a26ffb20402"></a>
static <a class="el" href="classcoro_1_1mutex_1_1awaiter.html">awaiter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro_1_1mutex.html#a6d73b5920fdf3bd9e2959a26ffb20402">locked</a> ()</td></tr>
<tr class="memdesc:a6d73b5920fdf3bd9e2959a26ffb20402"><td class="mdescLeft">&#160;</td><td class="mdescRight">generates special pointer, which is used as locked flag (value 0x00000001) <br /></td></tr>
<tr class="separator:a6d73b5920fdf3bd9e2959a26ffb20402"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a6699913b9e97fc8f728baf404674ecaf"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="classcoro_1_1mutex_1_1awaiter.html">awaiter</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro_1_1mutex.html#a6699913b9e97fc8f728baf404674ecaf">_req</a> = {nullptr}</td></tr>
<tr class="separator:a6699913b9e97fc8f728baf404674ecaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283b0c85b2776e768ed3ae13a4aca584"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoro_1_1mutex_1_1awaiter.html">awaiter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro_1_1mutex.html#a283b0c85b2776e768ed3ae13a4aca584">_que</a> = nullptr</td></tr>
<tr class="memdesc:a283b0c85b2776e768ed3ae13a4aca584"><td class="mdescLeft">&#160;</td><td class="mdescRight">contains queue of requests already registered by the lock  <a href="classcoro_1_1mutex.html#a283b0c85b2776e768ed3ae13a4aca584">More...</a><br /></td></tr>
<tr class="separator:a283b0c85b2776e768ed3ae13a4aca584"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Mutex which allows locking across co_await and co_yield suspend points. </p>
<p>This object can be used to hold exclusive access to a resource while the coroutine is suspended on co_await on co_yield. Standard mutex can't support such feature. This mutex is also co_awaitable.</p>
<p>The object suports lock and try_lock. However the lock protocol is different. When lock success, you receive an ownership object, which must be held to keep exclusive access. Once the ownership is released, the mutex is unlocked. The ownership object uses RAII to track to mutex ownership. So there is no explicit <a class="el" href="classcoro_1_1mutex.html#adda886fc0b4171935329781e05d92d24" title="unlock the lock">unlock()</a> function.</p>
<p>The mutex object support co_await, <a class="el" href="classcoro_1_1mutex.html#a0067038a6413cc3c34bfca3a8ef63314" title="lock synchronously">lock_sync()</a> and <a class="el" href="classcoro_1_1mutex.html#a66fc3958880800e8420a2b2ef34932c1" title="lock and call a function when access is granted">lock_callback()</a>. The third function allows to call a callback when lock is acquired. </p>

<p class="definition">Definition at line <a class="el" href="mutex_8h_source.html#l00027">27</a> of file <a class="el" href="mutex_8h_source.html">mutex.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a62a4ba298325045f272db9ea9c2e5098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a4ba298325045f272db9ea9c2e5098">&#9670;&nbsp;</a></span>build_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void coro::mutex::build_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoro_1_1mutex_1_1awaiter.html">awaiter</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoro_1_1mutex_1_1awaiter.html">awaiter</a> *&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>builds internal queue </p>
<p>Picks are requests and reorder them in reverse order so stack is converted to queue. This is done by the owner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer request stack (linked list) </td></tr>
    <tr><td class="paramname">stop</td><td>pointer to item, which is used as stop item (which is often first awaiter or locked flag) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mutex_8h_source.html#l00316">316</a> of file <a class="el" href="mutex_8h_source.html">mutex.h</a>.</p>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classcoro_1_1mutex_a62a4ba298325045f272db9ea9c2e5098_icgraph.png" border="0" usemap="#aclasscoro_1_1mutex_a62a4ba298325045f272db9ea9c2e5098_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ad0e661447e136717a63e38cf9047f20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e661447e136717a63e38cf9047f20b">&#9670;&nbsp;</a></span>do_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool coro::mutex::do_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoro_1_1mutex_1_1awaiter.html">awaiter</a> *&#160;</td>
          <td class="paramname"><em>awt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initiate lock operation </p>
<p>registers the awaiter as a new request. If it is first request, the lock has been acquired, builds queue of requests and returns false. Otherwise keeps awaiter registered and returns true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">awt</td><td>awaiter </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>can't registrer, we acquired ownership, so continue </td></tr>
    <tr><td class="paramname">true</td><td>registered, we can wait </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mutex_8h_source.html#l00298">298</a> of file <a class="el" href="mutex_8h_source.html">mutex.h</a>.</p>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classcoro_1_1mutex_ad0e661447e136717a63e38cf9047f20b_icgraph.png" border="0" usemap="#aclasscoro_1_1mutex_ad0e661447e136717a63e38cf9047f20b_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a66fc3958880800e8420a2b2ef34932c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fc3958880800e8420a2b2ef34932c1">&#9670;&nbsp;</a></span>lock_callback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::invocable&lt; ownership &gt; Fn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void coro::mutex::lock_callback </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>lock and call a function when access is granted </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>function to call. The function accepts an ownership. The function must not throw any exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function allocates an awaiter on the heap, it is automatically released after call is done. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mutex_8h_source.html#l00236">236</a> of file <a class="el" href="mutex_8h_source.html">mutex.h</a>.</p>

</div>
</div>
<a id="adc0ff76f662e2b2dfddf1501f8d54e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0ff76f662e2b2dfddf1501f8d54e67">&#9670;&nbsp;</a></span>lock_callback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::invocable&lt; ownership &gt; Fn, std::size_t sz&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void coro::mutex::lock_callback </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char(&amp;)&#160;</td>
          <td class="paramname"><em>buffer</em>[sz]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>lock and call a function when access is granted </p>
<p>The awaiter is allocated in static buffer. Size of the static buffer can be determined by a constant lock_callback_buffer_size</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>instance of function to call </td></tr>
    <tr><td class="paramname">buffer</td><td>reserved space of sufficient size, where the awaiter is temporary allocated. The buffer must stay valid until the callback is called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>doesn't allocate on heap </dd></dl>

<p class="definition">Definition at line <a class="el" href="mutex_8h_source.html#l00255">255</a> of file <a class="el" href="mutex_8h_source.html">mutex.h</a>.</p>

</div>
</div>
<a id="ae9c73d87232d3dd22e4dd45c0719206e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c73d87232d3dd22e4dd45c0719206e">&#9670;&nbsp;</a></span>try_acquire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool coro::mutex::try_acquire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tries to acquire </p>
<p>attempts to set _req to <a class="el" href="classcoro_1_1mutex.html#a6d73b5920fdf3bd9e2959a26ffb20402" title="generates special pointer, which is used as locked flag (value 0x00000001)">locked()</a> if it has nullptr </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>success, acquired </td></tr>
    <tr><td class="paramname">false</td><td>failed, lock is owned </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mutex_8h_source.html#l00283">283</a> of file <a class="el" href="mutex_8h_source.html">mutex.h</a>.</p>
<div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classcoro_1_1mutex_ae9c73d87232d3dd22e4dd45c0719206e_icgraph.png" border="0" usemap="#aclasscoro_1_1mutex_ae9c73d87232d3dd22e4dd45c0719206e_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a1b5fb2fd2995e2210181de3c4211ca6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5fb2fd2995e2210181de3c4211ca6f">&#9670;&nbsp;</a></span>try_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoro_1_1mutex_1_1ownership.html">ownership</a> coro::mutex::try_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>try to lock </p>
<dl class="section return"><dt>Returns</dt><dd>ownership. If the function fails, the ownership is not given. You need to convert ownership to bool and test it. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mutex_8h_source.html#l00214">214</a> of file <a class="el" href="mutex_8h_source.html">mutex.h</a>.</p>

</div>
</div>
<a id="adda886fc0b4171935329781e05d92d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda886fc0b4171935329781e05d92d24">&#9670;&nbsp;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoro_1_1prepared__coro.html">prepared_coro</a> coro::mutex::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>unlock the lock </p>
<p>if queue is empty, tries to swap <a class="el" href="classcoro_1_1mutex.html#a6d73b5920fdf3bd9e2959a26ffb20402" title="generates special pointer, which is used as locked flag (value 0x00000001)">locked()</a> to nullptr, however if this fails, it builds queue and continues with the queue</p>
<p>if queue is not empty, retrieves the first awaiter, removes it from the queue and resumes it, which transfers ownership to the new owner. </p>

<p class="definition">Definition at line <a class="el" href="mutex_8h_source.html#l00333">333</a> of file <a class="el" href="mutex_8h_source.html">mutex.h</a>.</p>
<div id="dynsection-4" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-4-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classcoro_1_1mutex_adda886fc0b4171935329781e05d92d24_icgraph.png" border="0" usemap="#aclasscoro_1_1mutex_adda886fc0b4171935329781e05d92d24_icgraph" alt=""/></div>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a283b0c85b2776e768ed3ae13a4aca584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283b0c85b2776e768ed3ae13a4aca584">&#9670;&nbsp;</a></span>_que</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoro_1_1mutex_1_1awaiter.html">awaiter</a>* coro::mutex::_que = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>contains queue of requests already registered by the lock </p>
<p>the queue is always managed by an owner <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="mutex_8h_source.html#l00274">274</a> of file <a class="el" href="mutex_8h_source.html">mutex.h</a>.</p>

</div>
</div>
<a id="a6699913b9e97fc8f728baf404674ecaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6699913b9e97fc8f728baf404674ecaf">&#9670;&nbsp;</a></span>_req</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="classcoro_1_1mutex_1_1awaiter.html">awaiter</a> *&gt; coro::mutex::_req = {nullptr}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>contains stack of requests, or nullptr when lock is unlocked, or 0x00000001 when lock is locked with no requests </p>

<p class="definition">Definition at line <a class="el" href="mutex_8h_source.html#l00271">271</a> of file <a class="el" href="mutex_8h_source.html">mutex.h</a>.</p>

</div>
</div>
<a id="ae4442e1f6d17f0cf3cfa45a16256b83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4442e1f6d17f0cf3cfa45a16256b83a">&#9670;&nbsp;</a></span>lock_callback_buffer_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t coro::mutex::lock_callback_buffer_size = sizeof(<a class="el" href="classcoro_1_1mutex_1_1awaiter__cb.html">awaiter_cb</a>&lt;Fn, true&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>contains required size of static buffer to hold awaiter for given function </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Fn</td><td>callback function type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mutex_8h_source.html#l00207">207</a> of file <a class="el" href="mutex_8h_source.html">mutex.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/coro/<a class="el" href="mutex_8h_source.html">mutex.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 16 2024 13:36:34 for libcoro by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
